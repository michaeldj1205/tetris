
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tetris Game</title>
    <style>
        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            height: 100vh;
            background-color: #222;
            color: white;
            font-family: Arial, sans-serif;
        }
        canvas {
            border: 2px solid white;
            background-color: black;
        }
        .info {
            display: flex;
            justify-content: space-between;
            width: 400px;
        }
    </style>
</head>
<body>
    <div class="info">
        <div>Score: <span id="score">0</span></div>
        <div>Next Piece:</div>
        <canvas id="next" width="120" height="120"></canvas>
    </div>
    <canvas id="tetris" width="300" height="600"></canvas>
    <script>
        const canvas = document.getElementById('tetris');
        const ctx = canvas.getContext('2d');
        const nextCanvas = document.getElementById('next');
        const nextCtx = nextCanvas.getContext('2d');
        const ROWS = 20;
        const COLUMNS = 10;
        const BLOCK_SIZE = 30;
        let score = 0;
        
        ctx.scale(BLOCK_SIZE, BLOCK_SIZE);
        nextCtx.scale(BLOCK_SIZE / 2, BLOCK_SIZE / 2);
        
        const arena = Array.from({ length: ROWS }, () => Array(COLUMNS).fill(0));
        
        const tetrominoes = [
            [[1, 1, 1, 1]],
            [[1, 1], [1, 1]],
            [[0, 1, 0], [1, 1, 1]],
            [[1, 0, 0], [1, 1, 1]],
            [[0, 0, 1], [1, 1, 1]],
            [[1, 1, 0], [0, 1, 1]],
            [[0, 1, 1], [1, 1, 0]]
        ];
        
        let piece = createPiece();
        let nextPiece = createPiece();
        let position = { x: 3, y: 0 };
        let dropCounter = 0;
        let lastTime = 0;
        
        function createPiece() {
            return tetrominoes[Math.floor(Math.random() * tetrominoes.length)];
        }
        
        function collide(arena, piece, offset) {
            return piece.some((row, y) =>
                row.some((cell, x) => cell && (arena[y + offset.y]?.[x + offset.x] !== 0))
            );
        }
        
        function merge(arena, piece, offset) {
            piece.forEach((row, y) => {
                row.forEach((cell, x) => {
                    if (cell) arena[y + offset.y][x + offset.x] = cell;
                });
            });
        }
        
        function clearLines() {
            for (let y = arena.length - 1; y >= 0; y--) {
                if (arena[y].every(cell => cell !== 0)) {
                    arena.splice(y, 1);
                    arena.unshift(Array(COLUMNS).fill(0));
                    score += 10;
                    document.getElementById('score').innerText = score;
                }
            }
        }
        
        function drop() {
            while (!collide(arena, piece, { x: position.x, y: position.y + 1 })) {
                position.y++;
            }
            merge(arena, piece, position);
            clearLines();
            position = { x: 3, y: 0 };
            piece = nextPiece;
            nextPiece = createPiece();
            if (collide(arena, piece, position)) {
                arena.forEach(row => row.fill(0));
                score = 0;
                document.getElementById('score').innerText = score;
            }
        }
        
        function update(time = 0) {
            const deltaTime = time - lastTime;
            lastTime = time;
            dropCounter += deltaTime;
            if (dropCounter > 1000) {
                position.y++;
                if (collide(arena, piece, position)) {
                    position.y--;
                    merge(arena, piece, position);
                    clearLines();
                    position = { x: 3, y: 0 };
                    piece = nextPiece;
                    nextPiece = createPiece();
                    if (collide(arena, piece, position)) {
                        arena.forEach(row => row.fill(0));
                        score = 0;
                        document.getElementById('score').innerText = score;
                    }
                }
                dropCounter = 0;
            }
            draw();
            requestAnimationFrame(update);
        }
        
        function move(offset) {
            position.x += offset;
            if (collide(arena, piece, position)) {
                position.x -= offset;
            }
        }
        
        function rotate() {
            const rotated = piece[0].map((_, i) => piece.map(row => row[i])).reverse();
            const oldPiece = piece;
            piece = rotated;
            if (collide(arena, piece, position)) {
                piece = oldPiece;
            }
        }
        
        document.addEventListener('keydown', event => {
            if (event.key === 'ArrowLeft') move(-1);
            if (event.key === 'ArrowRight') move(1);
            if (event.key === 'ArrowDown') position.y++;
            if (event.key === 'ArrowUp') rotate();
            if (event.key === ' ') drop();
        });
        
        update();
    </script>
</body>
</html>
